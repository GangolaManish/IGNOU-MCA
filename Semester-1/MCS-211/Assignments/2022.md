Assignment Reference Link : https://webservices.ignou.ac.in/assignments/Master-Degree/MCA_NEW/2022/mca_newsemester1july22%20(1).pdf

Course Code : MCS-211
Course Title : Design and Analysis of Algorithm
Assignment Number : MCA(1)/211/Assign/2022

Question 1. (a) What are the desirable characteristics of an algorithm? Find the GCD of
p = 144 and q = 55 using Euclidâ€™s algorithm.
Answer.
Algorithm
An algorithm is a set of steps to solve a problem or a set of problems. Also, an algorithm is a step by step procedure to solve logical and mathematical or computational problems.
[ A reciepe is a good example of algorithm. To cook a dish, a reciepe says what to be done step by step. ]

Important characterstics of an algorithm are:
(i) Input : There must be a finite number of inputs for the algorithm.
(ii) Output : Ther must be some output produced as a result of execution of the algorithm.
(iii) Definiteness : There must be a definite sequence of operations for transformation of input into output.
(iv) Effectiveness : Every step of the algorithm should be basic and essential.
(v) Finiteness : The transformation of input to output must be achieved in finite steps.

Desirable characterstics of an algorithm are:
(i) General : The algorithm should be general and is able to solve several cases.
(ii) Efficiency : The algorithm should use resources efficiently, i.e. takes less time and money in producing the result.
(iii) Understandability : The algorithms should be understandable and apply it to own problem.
(iv) Uniqueness : The algorithm should follow uniqueness such that instruction of the algorithm is unambiguous (synonyms : precise/absolute) and clear.

G.C.D. of p = 144 and q = 55 using Euclid's algorithm:
The pseudo code for computing G.C.D. (p,q) by Euclid's algorithm is as follows:
// p and q are two postive numbers where p is dividend and q is divisor.
(i) If q = 0, return p and exit.
(ii) Else, go to step (iii).
(iii) Divide p by q and assign the remainder to r.
(iv) Assign the value of q to p and the value of r to q and go back to step (i)

Euclid's algorithm to calculate G.C.D. (p,q)
begin [start of the algorithm]
{
    while (q != 0)
    {
        r <- p mod q
        p <- q
        q <- r
    } [end of while loop]
    return (q)
} [end of the algorithm]

Iteration 1:
(i) Divide p = 144 by q = 55 and store the remainder in r.
    r = 144 % 55 (here, % represents the remainder operator)
    r = 34
(ii) If r = 0, the algorithm terminates and q is the GCD. Otherwise, go to step (iii)
    Here, r is not zero, so we will go to step (iii)
(iii) The integer p will get the current value of integer q, and the new value of integer q will be the current value of r.
    Here, p = 55 and q = 34
(iv) Go back to step (i).

Iteration 2:
(i) Divide p = 55 by q = 34 and store the remainder in r.
    r = 55 % 34 (here, % represents the remainder operator)
    r = 21
(ii) If r = 0, the algorithm terminates and q is the GCD. Otherwise, go to step (iii)
    Here, r is not zero, so we will go to step (iii)
(iii) The integer p will get the current value of integer q, and the new value of integer q will be the current value of r.
    Here, p = 34 and q = 21
(iv) Go back to step (i).

Iteration 3:
(i) Divide p = 34 by q = 21 and store the remainder in r.
    r = 34 % 21 (here, % represents the remainder operator)
    r = 13
(ii) If r = 0, the algorithm terminates and q is the GCD. Otherwise, go to step (iii)
    Here, r is not zero, so we will go to step (iii)
(iii) The integer p will get the current value of integer q, and the new value of integer q will be the current value of r.
    Here, p = 21 and q = 13
(iv) Go back to step (i).

Iteration 4:
(i) Divide p = 21 by q = 13 and store the remainder in r.
    r = 21 % 13 (here, % represents the remainder operator)
    r = 8
(ii) If r = 0, the algorithm terminates and q is the GCD. Otherwise, go to step (iii)
    Here, r is not zero, so we will go to step (iii)
(iii) The integer p will get the current value of integer q, and the new value of integer q will be the current value of r.
    Here, p = 13 and q = 8
(iv) Go back to step (i).

Iteration 5:
(i) Divide p = 13 by q = 8 and store the remainder in r.
    r = 13 % 8 (here, % represents the remainder operator)
    r = 5
(ii) If r = 0, the algorithm terminates and q is the GCD. Otherwise, go to step (iii)
    Here, r is not zero, so we will go to step (iii)
(iii) The integer p will get the current value of integer q, and the new value of integer q will be the current value of r.
    Here, p = 8 and q = 5
(iv) Go back to step (i).

Iteration 6:
(i) Divide p = 8 by q = 5 and store the remainder in r.
    r = 8 % 5 (here, % represents the remainder operator)
    r = 3
(ii) If r = 0, the algorithm terminates and q is the GCD. Otherwise, go to step (iii)
    Here, r is not zero, so we will go to step (iii)
(iii) The integer p will get the current value of integer q, and the new value of integer q will be the current value of r.
    Here, p = 5 and q = 3
(iv) Go back to step (i).

Iteration 7:
(i) Divide p = 5 by q = 3 and store the remainder in r.
    r = 5 % 3 (here, % represents the remainder operator)
    r = 2
(ii) If r = 0, the algorithm terminates and q is the GCD. Otherwise, go to step (iii)
    Here, r is not zero, so we will go to step (iii)
(iii) The integer p will get the current value of integer q, and the new value of integer q will be the current value of r.
    Here, p = 3 and q = 2
(iv) Go back to step (i).

Iteration 8:
(i) Divide p = 3 by q = 2 and store the remainder in r.
    r = 3 % 2 (here, % represents the remainder operator)
    r = 1
(ii) If r = 0, the algorithm terminates and q is the GCD. Otherwise, go to step (iii)
    Here, r is not zero, so we will go to step (iii)
(iii) The integer p will get the current value of integer q, and the new value of integer q will be the current value of r.
    Here, p = 2 and q = 1
(iv) Go back to step (i).

Iteration 9:
(i) Divide p = 2 by q = 1 and store the remainder in r.
    r = 2 % 1 (here, % represents the remainder operator)
    r = 0
(ii) If r = 0, the algorithm terminates and q is the GCD. Otherwise, go to step (iii)
    Here, r is zero, so the algorithm terminates and q is the answer, i.e. 1.

Question 1 (b). Differentiate between Greedy Technique and Dynamic Programming
approach of problem solving. Name few problems which are solved
using these techniques.
Answer.
| Aspect  | Greedy Technique | Dynamic Programming |
| ------------- | ------------- |
| Approach  | Picks the locally optimal choice at each step, hoping it leads to global optimum. | Solves problem by dividing them into small sub-problems, solving each, storing results and combining them. |
| Objective | Focuses on making the best immediate choice without considering future consequences. | Considers all possible solutions to ensure the global optimum by solving all sub-problems systemically. |
| Optimal Solution | May not always produce the global optimal solution. | Always gurantees the global optimal solution, if applicable to the problem. |
| Complexity | Generally simpler and faster to design and implement. | Requires more computation and memory due to use of a table for storing sub-problem results. |
| Reusability | Does not store results; decisions are independent at each step. | Stores results of solved sub-problems to avoid redunant calculations (uses memoization or tabulation). |

Problems solved using Greedy Technique:
(i) Kruskal's Minimum Spanning Tree
(ii) Prim's Minimum Spanning Tree
(iii) Dijkstra's Shortest Path Algorithm
(iv) Fractional Knapsack Problem

Problems solved using Dynamic Programming:
(i) 0-1 Knapsack Problem
(ii) Subset-Sum Problem
(iii) Longest Common Subsequence (LCS)
(iv) Fibonacci Sequence Calculation
